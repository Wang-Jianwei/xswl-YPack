"""
NSIS script header generation — defines, includes, unicode, icons.
"""

from __future__ import annotations

import os
from typing import List, Optional

from .context import BuildContext
from .nsis_languages import NsisLanguageMapping, get_nsis_mapping_or_fallback
from .nsis_sections import collect_all_shortcuts
from ..config import LanguageConfig, LangText
from ..languages import (
    get_translated_string,
)


def generate_header(ctx: BuildContext) -> List[str]:
    """Top-of-file defines, Unicode flag, MUI icon defines."""
    cfg = ctx.config
    desc_text = LangText.from_value(cfg.app.description)
    if desc_text.translations and not cfg.languages:
        raise ValueError("app.description requires languages when using per-language values.")
    if desc_text.translations:
        desc_value = "$(APP_DESCRIPTION)"
    else:
        desc_value = ctx.resolve(desc_text.text).replace('"', '$\\"')

    lines: List[str] = [
        "; NSIS Script generated by xswl-YPack",
        "; Do not edit manually — regenerate from YAML configuration",
        "",
        "; --- Encoding ---",
        "Unicode true",
        "",
        "; --- Application Information ---",
        f'!define APP_NAME "{cfg.app.name}"',
        f'!define APP_VERSION "{cfg.app.version}"',
        f'!define APP_PUBLISHER "{cfg.app.publisher}"',
        f'!define APP_DESCRIPTION "{desc_value}"',
    ]

    # REG_KEY: user-configurable application registry key.
    # Default: Software\{publisher}\{app_name}  (industry standard).
    reg_key = cfg.install.registry_key
    if not reg_key:
        reg_key = f"Software\\{cfg.app.publisher}\\{cfg.app.name}"
    reg_key = ctx.resolve(reg_key)
    lines.append(f'!define REG_KEY "{reg_key}"')
    lines.append("")

    # MUI icon defines (must appear before !include MUI2.nsh)
    install_icon = cfg.app.install_icon
    uninstall_icon = cfg.app.uninstall_icon or install_icon
    if install_icon or uninstall_icon:
        lines.append("; --- Modern UI Icons ---")
        if install_icon:
            abs_path = ctx.resolve_path(install_icon)
            rel_path = ctx.relative_to_output(abs_path) if os.path.exists(abs_path) else install_icon
            if not os.path.exists(abs_path):
                lines.append(f"; WARNING: Install icon not found: {install_icon}")
            lines.append(f'!define MUI_ICON "{rel_path}"')
        if uninstall_icon:
            abs_path = ctx.resolve_path(uninstall_icon)
            rel_path = ctx.relative_to_output(abs_path) if os.path.exists(abs_path) else uninstall_icon
            if not os.path.exists(abs_path):
                lines.append(f"; WARNING: Uninstall icon not found: {uninstall_icon}")
            lines.append(f'!define MUI_UNICON "{rel_path}"')
        lines.append("")

    # License file (put near top with other top-level defines)
    license_text = LangText.from_value(cfg.app.license)
    if not license_text.is_empty():
        if license_text.translations:
            if not cfg.languages:
                raise ValueError("app.license requires languages when using per-language values.")
            default_lang = cfg.languages[0].name
            resolved = ctx.resolve(license_text.get_for_language(default_lang, "app.license"))
        else:
            resolved = ctx.resolve(license_text.text)
        abs_path = ctx.resolve_path(resolved)
        if os.path.exists(abs_path):
            rel_path = ctx.relative_to_output(abs_path)
            lines.append(f'!define LICENSE_FILE "{rel_path}"')
        else:
            lines.append(f"; WARNING: License file not found: {resolved}")
            lines.append(f'!define LICENSE_FILE "{resolved}"')

    return lines


def generate_custom_includes(ctx: BuildContext) -> List[str]:
    """Emit ``!include`` directives from ``custom_includes.nsis``."""
    includes = []
    ci = ctx.config.custom_includes
    if isinstance(ci, dict):
        includes = list(ci.get("nsis", []))
    if not includes:
        return []
    lines = ["; --- Custom NSIS Includes ---"]
    for inc in includes:
        lines.append(f'!include "{inc}"')
    lines.append("")
    return lines


def generate_general_settings(ctx: BuildContext) -> List[str]:
    """Name, OutFile, InstallDir, RequestExecutionLevel, BrandingText, license."""
    cfg = ctx.config
    reg_view = ctx.effective_reg_view
    lines: List[str] = [
        "; --- General Settings ---",
        f'Name "${{APP_NAME}}"',
        f'OutFile "${{APP_NAME}}-${{APP_VERSION}}-Setup.exe"',
        f'InstallDir "{ctx.resolve(cfg.install.install_dir)}"',
        f'InstallDirRegKey HKLM "${{REG_KEY}}" "InstallPath"',
        'RequestExecutionLevel admin',
    ]

    # BrandingText: defaults to publisher name if not explicitly set
    branding = cfg.app.branding
    if branding:
        branding = ctx.resolve(branding)
    else:
        # Default: use publisher name
        branding = cfg.app.publisher
    if branding:
        branding = branding.replace('"', '$\\"')
        lines.append(f'BrandingText "{branding}"')

    # License data belongs to general settings (keeps settings grouped together)
    license_text = LangText.from_value(cfg.app.license)
    if license_text.translations and not cfg.languages:
        raise ValueError("app.license requires languages when using per-language values.")

    # Silent install support
    if cfg.install.silent_install:
        lines.append("SilentInstall silent")

    # Logging
    if cfg.logging and cfg.logging.enabled:
        log_path = cfg.logging.path or "$APPDATA\\${APP_NAME}\\install.log"
        resolved_path = ctx.resolve(cfg.logging.path) if cfg.logging.path else log_path
        lines.append(f'; Logging: {resolved_path} (level={cfg.logging.level})')
        lines.append(f'!define LOG_FILE "{resolved_path}"')

    # Utility includes (provide helper macros used elsewhere, e.g. ${GetSize})
    lines.append('!include "FileFunc.nsh"')

    lines.append("")
    return lines


def _resolve_nsis_mapping(lang_cfg: LanguageConfig) -> NsisLanguageMapping:
    """Resolve a LanguageConfig to NSIS-specific identifiers, with fallback."""
    return get_nsis_mapping_or_fallback(lang_cfg.name)


def generate_modern_ui(ctx: BuildContext) -> List[str]:
    """MUI2 include, page macros, language macros, finish-page run."""
    cfg = ctx.config
    # Finish page run — implement with a custom finish page checkbox instead
    # of relying on MUI_FINISHPAGE_RUN (avoids makensis 6010 warnings in some
    # MUI/NSIS versions which treat unreferenced GUIInit as an error).
    launch = cfg.install.launch_on_finish
    lines: List[str] = [
        "; --- Modern UI ---",
    ]
    lines.extend([
        '!include "MUI2.nsh"',
        "",
    ])

    # Emit fallback LANG_* constants for every configured language so
    # that LangString definitions can be placed before MUI_LANGUAGE
    # macros without causing undefined-constant errors.  The MUI_LANGUAGE
    # macro will define them again (harmlessly) when it is processed.
    langs: List[LanguageConfig] = cfg.languages or []
    if langs:
        lines.append('; --- Language constant fallbacks ---')
        for lang_cfg in langs:
            mapping = _resolve_nsis_mapping(lang_cfg)
            if mapping.lcid > 0:
                lines.extend([
                    f'!ifndef {mapping.lang_constant}',
                    f'  !define {mapping.lang_constant} {mapping.lcid}',
                    f'!endif',
                ])
        lines.append('')
    else:
        # Always define LANG_ENGLISH as safety net for description
        # LangString when no languages are configured.
        lines.extend([
            '!ifndef LANG_ENGLISH',
            '  !define LANG_ENGLISH 1033',
            '!endif',
            '',
        ])
    # If a launch-on-finish path is configured, add a localized finish-page
    # checkbox implemented with nsDialogs (more robust across MUI versions).
    label_override = LangText.from_value(cfg.install.launch_on_finish_label)
    if launch:
        path = ctx.resolve(launch)
        label_text = ""
        if not label_override.is_empty():
            if label_override.translations and not langs:
                raise ValueError(
                    "launch_on_finish_label requires languages when using per-language values."
                )
            label_text = ctx.resolve(label_override.text)
            label_text = label_text.replace('"', '$\\"')

        # When languages are configured we use a LangString reference
        # (runtime-resolved) for the checkbox label; otherwise hardcode English.
        if langs:
            finish_label = '$(FINISHPAGE_RUN_TEXT)'
        elif label_text:
            finish_label = f'"{label_text}"'
        else:
            finish_label = '"Run ${APP_NAME}"'
        lines.extend([
            'Var RUN_ON_FINISH',
            'Var _FINISH_RUN_CTRL',
            '',
            # Show/leave callbacks for the Finish page
            'Function Finish_Create',
            '  nsDialogs::Create 1018',
            '  Pop $0',
            '  StrCmp $0 error 0 +2',
            '    Abort',
            f'  ${{NSD_CreateCheckBox}} 10u 10u 100% 12u {finish_label}',
            '  Pop $_FINISH_RUN_CTRL',
            '  ${NSD_SetState} $_FINISH_RUN_CTRL 1',
            '  nsDialogs::Show',
            'FunctionEnd',
            '',
            'Function Finish_Leave',
            '  ${NSD_GetState} $_FINISH_RUN_CTRL $0',
            '  StrCmp $0 1 0 +2',
            '    StrCpy $RUN_ON_FINISH 1',
            '    Goto +2',
            '  StrCpy $RUN_ON_FINISH 0',
            '  ; If selected, run the configured program',
            f'  StrCmp $RUN_ON_FINISH "1" 0 +2',
            f'    ExecShell open "{path}"',
            'FunctionEnd',
            '',
        ])

    # License page is handled below in the UI Pages section using
    # MUI_PAGE_LICENSE + LicenseLangString (compile-time embedding).

    # UI Pages
    lines.append("; UI Pages")

    # Languages configured in YAML — determine behavior (default: no languages).
    langs = cfg.languages or []

    # Language selection behavior:
    # - No configured languages: emit MUI_LANGUAGE "English" as default
    #   (MUI2 requires at least one MUI_LANGUAGE to define its internal LangStrings).
    # - One language: emit a single MUI_LANGUAGE for that language.
    # - Multiple languages: emit a short introduction page (localized) followed
    #   by MUI_PAGE_LANGUAGE so the user can choose at install time.
    if langs:
        # Multi-language selection uses MUI_LANGDLL_DISPLAY in .onInit
        # so that $LANGUAGE is set before UI initialization.
        # Emit mapped MUI_LANGUAGE entries.
        for lang_cfg in langs:
            mapping = _resolve_nsis_mapping(lang_cfg)
            lines.append(f'!insertmacro MUI_LANGUAGE "{mapping.mui_name}"')
    else:
        # No languages configured — default to English so MUI2 internal
        # LangStrings (e.g. MUI_INNERTEXT_LICENSE_BOTTOM) are defined.
        lines.append('!insertmacro MUI_LANGUAGE "English"')

    # License page using built-in MUI_PAGE_LICENSE + LicenseLangString
    license_text = LangText.from_value(cfg.app.license)
    if license_text.translations and not langs:
        raise ValueError("app.license requires languages when using per-language values.")
    if not license_text.is_empty():
        # For multilingual: emit LicenseLangString definitions
        # (must come after MUI_LANGUAGE so ${LANG_*} constants are defined)
        if license_text.translations:
            lines.append('')
            lines.append('; License data per language (compile-time embedding)')
            for lang_cfg in langs:
                mapping = _resolve_nsis_mapping(lang_cfg)
                lc = f'${{{mapping.lang_constant}}}'
                path = license_text.get_for_language(lang_cfg.name, "app.license")
                resolved = ctx.resolve(path)
                abs_path = ctx.resolve_path(resolved)
                if not os.path.exists(abs_path):
                    lines.append(f'; WARNING: License file not found: {resolved}')
                rel_path = ctx.relative_to_output(abs_path) if os.path.exists(abs_path) else resolved
                lines.append(f'LicenseLangString license_data {lc} "{rel_path}"')
            lines.append('')
        # Insert license page with acceptance checkbox
        lines.append('!define MUI_LICENSEPAGE_CHECKBOX')
        if license_text.translations:
            lines.append('!insertmacro MUI_PAGE_LICENSE $(license_data)')
        else:
            # Single-language: use direct file path
            resolved = ctx.resolve(license_text.text)
            abs_path = ctx.resolve_path(resolved)
            rel_path = ctx.relative_to_output(abs_path) if os.path.exists(abs_path) else resolved
            lines.append(f'!insertmacro MUI_PAGE_LICENSE "{rel_path}"')
    else:
        lines.append("; No license page")

    if cfg.packages:
        lines.append("!insertmacro MUI_PAGE_COMPONENTS")

    # If existing-install handling allows multiple installations, we
    # defer path-specific checks until the user has chosen an install
    # directory. Use a custom leave-callback on the directory page.
    ei = cfg.install.existing_install
    if ei and ei.allow_multiple:
        lines.extend([
            '!define MUI_PAGE_CUSTOMFUNCTION_LEAVE ExistingInstall_DirLeave',
            '!insertmacro MUI_PAGE_DIRECTORY',
            '!ifdef MUI_PAGE_CUSTOMFUNCTION_LEAVE',
            '  !undef MUI_PAGE_CUSTOMFUNCTION_LEAVE',
            '!endif',
        ])
    else:
        lines.append("!insertmacro MUI_PAGE_DIRECTORY")

    # Shortcut options page — per-shortcut checkboxes
    # Collect ALL shortcut definitions (global + per-package)
    _all_shortcuts = collect_all_shortcuts(ctx)
    if _all_shortcuts:
        lines.append('; Shortcut options page')
        lines.append('!include "nsDialogs.nsh"')
        lines.append('!include "WinMessages.nsh"')
        # Declare per-shortcut variables
        for sc in _all_shortcuts:
            lines.append(f'Var CREATE_SC_{sc.idx}')
        for sc in _all_shortcuts:
            lines.append(f'Var _SC_CTRL_{sc.idx}')
        lines.append('')

        # Build checkbox labels
        sc_labels: List[str] = []
        for sc in _all_shortcuts:
            if langs:
                sc_labels.append(f'$(SC_LABEL_{sc.idx})')
            else:
                if sc.sc_type == "desktop":
                    sc_labels.append(f'"Create desktop shortcut: {sc.resolved_name}"')
                else:
                    sc_labels.append(f'"Create start menu shortcut: {sc.resolved_name}"')

        lines.append('Function ShortcutOptions_Create')
        lines.append('  nsDialogs::Create 1018')
        lines.append('  Pop $0')
        lines.append('  StrCmp $0 error 0 +2')
        lines.append('    Abort')
        y_pos = 10
        for sc in _all_shortcuts:
            lines.append(f'  ${{NSD_CreateCheckBox}} 10u {y_pos}u 100% 12u {sc_labels[sc.idx]}')
            lines.append(f'  Pop $_SC_CTRL_{sc.idx}')
            lines.append(f'  ${{NSD_SetState}} $_SC_CTRL_{sc.idx} 1')
            y_pos += 18
        lines.append('  nsDialogs::Show')
        lines.append('FunctionEnd')
        lines.append('')
        lines.append('Function ShortcutOptions_Leave')
        for sc in _all_shortcuts:
            lines.append(f'  ${{NSD_GetState}} $_SC_CTRL_{sc.idx} $CREATE_SC_{sc.idx}')
        lines.append('FunctionEnd')
        lines.append('')
        lines.append('Page custom ShortcutOptions_Create ShortcutOptions_Leave')
        lines.append('')

    lines.extend([
        "!insertmacro MUI_PAGE_INSTFILES",
        "Page custom Finish_Create Finish_Leave",
        "",
        "!insertmacro MUI_UNPAGE_CONFIRM",
        "!insertmacro MUI_UNPAGE_INSTFILES",
        "",
    ])

    # Localized strings for shortcut options page — emit after MUI_LANGUAGE so
    # ${LANG_*} constants are defined by MUI2.nsh and the language macros.
    # Only emit if languages are configured (otherwise suppress LangString usage).
    if _all_shortcuts:
        if langs:  # Only if languages are configured
            lines.append('; Shortcut options localized strings')
            for sc in _all_shortcuts:
                for lang_cfg in langs:
                    mapping = _resolve_nsis_mapping(lang_cfg)
                    lc = f'${{{mapping.lang_constant}}}'
                    if sc.sc_type == "desktop":
                        base = get_translated_string(lang_cfg.name, 'shortcuts_desktop', lang_cfg.strings)
                    else:
                        base = get_translated_string(lang_cfg.name, 'shortcuts_startmenu', lang_cfg.strings)
                    label = f"{base}: {sc.resolved_name}"
                    label_escaped = label.replace('"', '$\\"')
                    lines.append(f'LangString SC_LABEL_{sc.idx} {lc} "{label_escaped}"')
            lines.append('')
        else:
            lines.append('; Shortcut options localized strings')
            lines.append('')

    # Localized strings for language selection intro page (only shown when multiple languages configured)
    if langs and len(langs) > 1:
        lines.append('; Language page localized strings')
        for lang_cfg in langs:
            mapping = _resolve_nsis_mapping(lang_cfg)
            lc = f'${{{mapping.lang_constant}}}'
            title = get_translated_string(lang_cfg.name, 'langpage_title', lang_cfg.strings)
            desc = get_translated_string(lang_cfg.name, 'langpage_desc', lang_cfg.strings)
            lines.append(f'LangString LANGPAGE_TITLE {lc} "{title}"')
            lines.append(f'LangString LANGPAGE_DESC {lc} "{desc}"')
        lines.append('')

    # Localized strings for file association descriptions (if configured)
    fa_list = cfg.install.file_associations or []
    if langs and fa_list:
        fa_has_i18n = any(LangText.from_value(fa.description).translations for fa in fa_list)
        if fa_has_i18n:
            lines.append('; File association localized strings')
            for idx, fa in enumerate(fa_list):
                desc_text = LangText.from_value(fa.description)
                if not desc_text.translations:
                    continue
                for lang_cfg in langs:
                    mapping = _resolve_nsis_mapping(lang_cfg)
                    lc = f'${{{mapping.lang_constant}}}'
                    text = desc_text.get_for_language(
                        lang_cfg.name,
                        f"file_associations[{idx}].description",
                    )
                    text = ctx.resolve(text).replace('"', '$\\"')
                    lines.append(f'LangString FA_DESC_{idx} {lc} "{text}"')
            lines.append('')

    desc_text = LangText.from_value(cfg.app.description)
    # Localized strings for app description (if configured)
    if langs and desc_text.translations:
        lines.append('; App description localized strings')
        for lang_cfg in langs:
            mapping = _resolve_nsis_mapping(lang_cfg)
            lc = f'${{{mapping.lang_constant}}}'
            text = desc_text.get_for_language(lang_cfg.name, "app.description")
            text = ctx.resolve(text).replace('"', '$\\"')
            lines.append(f'LangString APP_DESCRIPTION {lc} "{text}"')
        lines.append('')

    # License page LangStrings are no longer needed here — LicenseLangString
    # (emitted above with the license page) embeds the content at compile time,
    # and MUI_LICENSEPAGE_CHECKBOX provides the acceptance UI automatically.

    # Localized strings for finish-page run checkbox (if configured)
    if launch and langs:
        lines.append('; Finish page localized strings')
        for lang_cfg in langs:
            mapping = _resolve_nsis_mapping(lang_cfg)
            lc = f'${{{mapping.lang_constant}}}'
            if not label_override.is_empty():
                text = label_override.get_for_language(
                    lang_cfg.name,
                    "install.launch_on_finish_label",
                )
            else:
                text = get_translated_string(lang_cfg.name, 'finish_run', lang_cfg.strings)
            text = ctx.resolve(text).replace('"', '$\\"')
            lines.append(f'LangString FINISHPAGE_RUN_TEXT {lc} "{text}"')
        lines.append('')

    return lines
