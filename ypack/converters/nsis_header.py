"""
NSIS script header generation — defines, includes, unicode, icons.
"""

from __future__ import annotations

import os
import re
from typing import List, Optional

from .context import BuildContext
from .nsis_languages import NsisLanguageMapping, get_nsis_mapping_or_fallback
from .nsis_sections import collect_all_shortcuts
from ..config import LanguageConfig, LangText
from ..languages import (
    get_translated_string,
)


def _escape_nsis_langstring(text: str) -> str:
    """Escape and normalize text for use in NSIS LangString definitions.

    Handles:
    1. Quote escaping: " → $\"
    2. Stray dollar markers normalization: $\r$ → \r, $\n$ → \n
    3. Newline escaping: \r\n → $\r$\n, \r → $\r, \n → $\n

    This ensures the text can be placed on a single line in a LangString statement
    while preserving NSIS newline semantics.

    Args:
        text: Raw translated or resolved text that may contain quotes, newlines, or
              previously-escaped markers.

    Returns:
        Text safe for insertion into a NSIS LangString value on a single line.
    """
    text = text.replace('"', '$\\"')
    # Normalize any stray dollar markers around CR/LF (e.g. from prior processing)
    text = text.replace('$\r$', '\r').replace('$\n$', '\n')
    # Escape newlines for single-line NSIS LangString
    text = text.replace('\r\n', '$\\r$\\n').replace('\r', '$\\r').replace('\n', '$\\n')
    return text


def _normalize_vi_product_version(version_str: Optional[str]) -> str:
    """Normalize an optional version string into a VIProductVersion-compatible
    dotted-quad (a.b.c.d) where each component is 0..65535.

    If version_str is None or empty, returns "0.0.0.0".
    Otherwise extracts up to 4 numeric components and clamps to valid range.

    Examples:
    - None -> "0.0.0.0"
    - "1.2.3" -> "1.2.3.0"
    - "2026.1.23.0" -> "2026.1.23.0"
    """
    if not version_str or not version_str.strip():
        return "0.0.0.0"

    # Extract numeric components
    nums = [int(x) for x in re.findall(r"\d+", version_str)[:4]]
    while len(nums) < 4:
        nums.append(0)

    # Clamp to 16-bit words for VS_FIXEDFILEINFO
    parts = [min(max(p, 0), 65535) for p in nums]
    return ".".join(str(p) for p in parts)



def generate_header(ctx: BuildContext) -> List[str]:
    """Top-of-file defines, Unicode flag, MUI icon defines."""
    cfg = ctx.config
    desc_text = LangText.from_value(cfg.app.description)
    if desc_text.translations and not cfg.languages:
        raise ValueError("app.description requires languages when using per-language values.")
    if desc_text.translations:
        desc_value = "$(APP_DESCRIPTION)"
    else:
        desc_value = ctx.resolve(desc_text.text).replace('"', '$\\"')

    lines: List[str] = [
        "; NSIS Script generated by xswl-YPack",
        "; Do not edit manually — regenerate from YAML configuration",
        "",
        "; --- Encoding ---",
        "Unicode true",
        "",
        "; --- Application Information ---",
        f'!define APP_NAME "{cfg.app.name}"',
        f'!define APP_VERSION "{cfg.app.version}"',
        f'!define APP_VERSION_VI "{_normalize_vi_product_version(cfg.app.vi_product_version)}"',
        f'!define APP_PUBLISHER "{cfg.app.publisher}"',
        f'!define APP_DESCRIPTION "{desc_value}"',
    ]

    # REG_KEY: user-configurable application registry key.
    # Default: Software\{publisher}\{app_name}  (industry standard).
    reg_key = cfg.install.registry_key
    if not reg_key:
        reg_key = f"Software\\{cfg.app.publisher}\\{cfg.app.name}"
    reg_key = ctx.resolve(reg_key)
    lines.append(f'!define REG_KEY "{reg_key}"')
    lines.append("")

    # MUI icon defines (must appear before !include MUI2.nsh)
    install_icon = cfg.app.install_icon
    uninstall_icon = cfg.app.uninstall_icon or install_icon
    if install_icon or uninstall_icon:
        lines.append("; --- Modern UI Icons ---")
        if install_icon:
            abs_path = ctx.resolve_path(install_icon)
            rel_path = ctx.relative_to_output(abs_path) if os.path.exists(abs_path) else install_icon
            if not os.path.exists(abs_path):
                lines.append(f"; WARNING: Install icon not found: {install_icon}")
            lines.append(f'!define MUI_ICON "{rel_path}"')
        if uninstall_icon:
            abs_path = ctx.resolve_path(uninstall_icon)
            rel_path = ctx.relative_to_output(abs_path) if os.path.exists(abs_path) else uninstall_icon
            if not os.path.exists(abs_path):
                lines.append(f"; WARNING: Uninstall icon not found: {uninstall_icon}")
            lines.append(f'!define MUI_UNICON "{rel_path}"')
        lines.append("")

    # License file (put near top with other top-level defines)
    license_text = LangText.from_value(cfg.app.license)
    if not license_text.is_empty():
        if license_text.translations:
            if not cfg.languages:
                raise ValueError("app.license requires languages when using per-language values.")
            default_lang = cfg.languages[0].name
            resolved = ctx.resolve(license_text.get_for_language(default_lang, "app.license"))
        else:
            resolved = ctx.resolve(license_text.text)
        abs_path = ctx.resolve_path(resolved)
        if os.path.exists(abs_path):
            rel_path = ctx.relative_to_output(abs_path)
            lines.append(f'!define LICENSE_FILE "{rel_path}"')
        else:
            lines.append(f"; WARNING: License file not found: {resolved}")
            lines.append(f'!define LICENSE_FILE "{resolved}"')

    return lines


def generate_custom_includes(ctx: BuildContext) -> List[str]:
    """Emit ``!include`` directives from ``custom_includes.nsis``."""
    includes = []
    ci = ctx.config.custom_includes
    if isinstance(ci, dict):
        includes = list(ci.get("nsis", []))
    if not includes:
        return []
    lines = ["; --- Custom NSIS Includes ---"]
    for inc in includes:
        lines.append(f'!include "{inc}"')
    lines.append("")
    return lines


def generate_general_settings(ctx: BuildContext) -> List[str]:
    """Name, OutFile, InstallDir, RequestExecutionLevel, BrandingText, license."""
    cfg = ctx.config
    reg_view = ctx.effective_reg_view
    lines: List[str] = [
        "; --- General Settings ---",
        "; --- Version Info (applies to installer and uninstaller stub) ---",
        'VIProductVersion "${APP_VERSION_VI}"',
        'VIAddVersionKey "FileVersion" "${APP_VERSION_VI}"',
        'VIAddVersionKey "ProductVersion" "${APP_VERSION}"',
        'VIAddVersionKey "ProductName" "${APP_NAME}"',
        'VIAddVersionKey "CompanyName" "${APP_PUBLISHER}"',
        'VIAddVersionKey "FileDescription" "${APP_NAME} Installer"',
        'VIAddVersionKey "LegalCopyright" "Copyright (c) ${APP_PUBLISHER}"',
        '',
        f'Name "${{APP_NAME}}"',
        f'OutFile "${{APP_NAME}}-${{APP_VERSION}}-Setup.exe"',
        f'InstallDir "{ctx.resolve(cfg.install.install_dir)}"',
        f'InstallDirRegKey HKLM "${{REG_KEY}}" "InstallPath"',
        'RequestExecutionLevel admin',
    ]

    # BrandingText: defaults to publisher name if not explicitly set
    branding = cfg.app.branding
    if branding:
        branding = ctx.resolve(branding)
    else:
        # Default: use publisher name
        branding = cfg.app.publisher
    if branding:
        branding = branding.replace('"', '$\\"')
        lines.append(f'BrandingText "{branding}"')

    # License data belongs to general settings (keeps settings grouped together)
    license_text = LangText.from_value(cfg.app.license)
    if license_text.translations and not cfg.languages:
        raise ValueError("app.license requires languages when using per-language values.")

    # Silent install support
    if cfg.install.silent_install:
        lines.append("SilentInstall silent")

    # Logging
    if cfg.logging and cfg.logging.enabled:
        log_path = cfg.logging.path or "$APPDATA\\${APP_NAME}\\install.log"
        resolved_path = ctx.resolve(cfg.logging.path) if cfg.logging.path else log_path
        lines.append(f'; Logging: {resolved_path} (level={cfg.logging.level})')
        lines.append(f'!define LOG_FILE "{resolved_path}"')

    # Utility includes (provide helper macros used elsewhere, e.g. ${GetSize})
    lines.append('!include "FileFunc.nsh"')

    lines.append("")
    return lines


def _resolve_nsis_mapping(lang_cfg: LanguageConfig) -> NsisLanguageMapping:
    """Resolve a LanguageConfig to NSIS-specific identifiers, with fallback."""
    return get_nsis_mapping_or_fallback(lang_cfg.name)


def generate_modern_ui(ctx: BuildContext) -> List[str]:
    """MUI2 include, page macros, language macros, finish-page run."""
    cfg = ctx.config
    # Finish page run — implement with a custom finish page checkbox instead
    # of relying on MUI_FINISHPAGE_RUN (avoids makensis 6010 warnings in some
    # MUI/NSIS versions which treat unreferenced GUIInit as an error).
    launch = cfg.install.launch_on_finish
    lines: List[str] = [
        "; --- Modern UI ---",
    ]
    lines.extend([
        '!include "MUI2.nsh"',
        "",
    ])

    # Emit fallback LANG_* constants for every configured language so
    # that LangString definitions can be placed before MUI_LANGUAGE
    # macros without causing undefined-constant errors.  The MUI_LANGUAGE
    # macro will define them again (harmlessly) when it is processed.
    langs: List[LanguageConfig] = cfg.languages or []
    if langs:
        lines.append('; --- Language constant fallbacks ---')
        for lang_cfg in langs:
            mapping = _resolve_nsis_mapping(lang_cfg)
            if mapping.lcid > 0:
                lines.extend([
                    f'!ifndef {mapping.lang_constant}',
                    f'  !define {mapping.lang_constant} {mapping.lcid}',
                    f'!endif',
                ])
        lines.append('')
    else:
        # Always define LANG_ENGLISH as safety net for description
        # LangString when no languages are configured.
        lines.extend([
            '!ifndef LANG_ENGLISH',
            '  !define LANG_ENGLISH 1033',
            '!endif',
            '',
        ])
    # If a launch-on-finish path is configured, add a localized finish-page
    # checkbox implemented with nsDialogs (more robust across MUI versions).
    label_override = LangText.from_value(cfg.install.launch_on_finish_label)
    if launch:
        path = ctx.resolve(launch)
        label_text = ""
        if not label_override.is_empty():
            if label_override.translations and not langs:
                raise ValueError(
                    "launch_on_finish_label requires languages when using per-language values."
                )
            label_text = ctx.resolve(label_override.text)
            label_text = label_text.replace('"', '$\\"')

        # When languages are configured we use a LangString reference
        # (runtime-resolved) for the checkbox label; otherwise hardcode English.
        if langs:
            finish_label = '$(FINISHPAGE_RUN_TEXT)'
        elif label_text:
            finish_label = f'"{label_text}"'
        else:
            finish_label = '"Run ${APP_NAME}"'
        lines.extend([
            'Var RUN_ON_FINISH',
            'Var _FINISH_RUN_CTRL',
            '',
            # Show/leave callbacks for the Finish page
            'Function Finish_Create',
            '  nsDialogs::Create 1018',
            '  Pop $0',
            '  StrCmp $0 error 0 +2',
            '    Abort',
            f'  ${{NSD_CreateCheckBox}} 10u 10u 100% 12u {finish_label}',
            '  Pop $_FINISH_RUN_CTRL',
            '  ${NSD_SetState} $_FINISH_RUN_CTRL 1',
            '  nsDialogs::Show',
            'FunctionEnd',
            '',
            'Function Finish_Leave',
            '  ${NSD_GetState} $_FINISH_RUN_CTRL $0',
            '  StrCmp $0 1 0 +2',
            '    StrCpy $RUN_ON_FINISH 1',
            '    Goto +2',
            '  StrCpy $RUN_ON_FINISH 0',
            '  ; If selected, run the configured program',
            f'  StrCmp $RUN_ON_FINISH "1" 0 +2',
            f'    ExecShell open "{path}"',
            'FunctionEnd',
            '',
        ])

    # License page is handled below in the UI Pages section using
    # MUI_PAGE_LICENSE + LicenseLangString (compile-time embedding).

    # UI Pages
    lines.append("; UI Pages")

    # Languages configured in YAML — determine behavior (default: no languages).
    langs = cfg.languages or []

    # Language selection behavior:
    # - No configured languages: emit MUI_LANGUAGE "English" as default
    #   (MUI2 requires at least one MUI_LANGUAGE to define its internal LangStrings).
    # - One language: emit a single MUI_LANGUAGE for that language.
    # - Multiple languages: emit a short introduction page (localized) followed
    #   by MUI_PAGE_LANGUAGE so the user can choose at install time.
    if langs:
        # Multi-language selection uses MUI_LANGDLL_DISPLAY in .onInit
        # so that $LANGUAGE is set before UI initialization.
        # Emit mapped MUI_LANGUAGE entries.
        for lang_cfg in langs:
            mapping = _resolve_nsis_mapping(lang_cfg)
            lines.append(f'!insertmacro MUI_LANGUAGE "{mapping.mui_name}"')
    else:
        # No languages configured — default to English so MUI2 internal
        # LangStrings (e.g. MUI_INNERTEXT_LICENSE_BOTTOM) are defined.
        lines.append('!insertmacro MUI_LANGUAGE "English"')

    # License page using built-in MUI_PAGE_LICENSE + LicenseLangString
    license_text = LangText.from_value(cfg.app.license)
    if license_text.translations and not langs:
        raise ValueError("app.license requires languages when using per-language values.")
    if not license_text.is_empty():
        # For multilingual: emit LicenseLangString definitions
        # (must come after MUI_LANGUAGE so ${LANG_*} constants are defined)
        if license_text.translations:
            lines.append('')
            lines.append('; License data per language (compile-time embedding)')
            for lang_cfg in langs:
                mapping = _resolve_nsis_mapping(lang_cfg)
                lc = f'${{{mapping.lang_constant}}}'
                path = license_text.get_for_language(lang_cfg.name, "app.license")
                resolved = ctx.resolve(path)
                abs_path = ctx.resolve_path(resolved)
                if not os.path.exists(abs_path):
                    lines.append(f'; WARNING: License file not found: {resolved}')
                rel_path = ctx.relative_to_output(abs_path) if os.path.exists(abs_path) else resolved
                lines.append(f'LicenseLangString license_data {lc} "{rel_path}"')
            lines.append('')
        # Insert license page with acceptance checkbox
        lines.append('!define MUI_LICENSEPAGE_CHECKBOX')
        if license_text.translations:
            lines.append('!insertmacro MUI_PAGE_LICENSE $(license_data)')
        else:
            # Single-language: use direct file path
            resolved = ctx.resolve(license_text.text)
            abs_path = ctx.resolve_path(resolved)
            rel_path = ctx.relative_to_output(abs_path) if os.path.exists(abs_path) else resolved
            lines.append(f'!insertmacro MUI_PAGE_LICENSE "{rel_path}"')
    else:
        lines.append("; No license page")

    if cfg.packages:
        lines.append("!insertmacro MUI_PAGE_COMPONENTS")

    # If existing-install handling allows multiple installations, we
    # defer path-specific checks until the user has chosen an install
    # directory. Use a custom leave-callback on the directory page.
    ei = cfg.install.existing_install
    if ei and ei.allow_multiple:
        lines.extend([
            '!define MUI_PAGE_CUSTOMFUNCTION_LEAVE ExistingInstall_DirLeave',
            '!insertmacro MUI_PAGE_DIRECTORY',
            '!ifdef MUI_PAGE_CUSTOMFUNCTION_LEAVE',
            '  !undef MUI_PAGE_CUSTOMFUNCTION_LEAVE',
            '!endif',
        ])
    else:
        lines.append("!insertmacro MUI_PAGE_DIRECTORY")

    # Shortcut options page — per-shortcut checkboxes
    # Collect ALL shortcut definitions (global + per-package)
    _all_shortcuts = collect_all_shortcuts(ctx)
    _optional_shortcuts = [sc for sc in _all_shortcuts if sc.config.optional]
    if _all_shortcuts:
        lines.append('; Shortcut options variables')
        for sc in _all_shortcuts:
            lines.append(f'Var CREATE_SC_{sc.idx}')
        if _optional_shortcuts:
            lines.append('!include "nsDialogs.nsh"')
            lines.append('!include "WinMessages.nsh"')
            for sc in _optional_shortcuts:
                lines.append(f'Var _SC_CTRL_{sc.idx}')
        lines.append('')

    def _default_label(sc, lang_cfg: Optional[LanguageConfig]) -> str:
        label = sc.config.label
        if label.translations:
            if not lang_cfg:
                raise ValueError("shortcut.label requires languages when using per-language values.")
            text = label.get_for_language(lang_cfg.name, f"shortcuts[{sc.idx}].label")
        elif label.text:
            text = label.text
        else:
            if sc.sc_type == "desktop":
                if lang_cfg:
                    base = get_translated_string(lang_cfg.name, 'shortcuts_desktop', lang_cfg.strings)
                else:
                    base = get_translated_string("English", 'shortcuts_desktop', {})
                text = f"{base}: {sc.resolved_name}"
            elif sc.sc_type == "startmenu":
                if lang_cfg:
                    base = get_translated_string(lang_cfg.name, 'shortcuts_startmenu', lang_cfg.strings)
                else:
                    base = get_translated_string("English", 'shortcuts_startmenu', {})
                text = f"{base}: {sc.resolved_name}"
            elif sc.sc_type == "quicklaunch":
                text = f"Create quick launch shortcut: {sc.resolved_name}"
            else:
                text = f"Create shortcut: {sc.resolved_name}"
        return ctx.resolve(text)

    if _optional_shortcuts:
        lines.append('; Shortcut options page')
        # Build checkbox labels
        sc_labels: List[str] = []
        for sc in _optional_shortcuts:
            if langs:
                sc_labels.append(f'$(SC_LABEL_{sc.idx})')
            else:
                label = _default_label(sc, None)
                label = _escape_nsis_langstring(label)
                sc_labels.append(f'"{label}"')

        lines.append('Function ShortcutOptions_Create')
        lines.append('  nsDialogs::Create 1018')
        lines.append('  Pop $0')
        lines.append('  StrCmp $0 error 0 +2')
        lines.append('    Abort')
        y_pos = 10
        for idx, sc in enumerate(_optional_shortcuts):
            lines.append(f'  ${{NSD_CreateCheckBox}} 10u {y_pos}u 100% 12u {sc_labels[idx]}')
            lines.append(f'  Pop $_SC_CTRL_{sc.idx}')
            state = 1 if sc.config.default else 0
            lines.append(f'  ${{NSD_SetState}} $_SC_CTRL_{sc.idx} {state}')
            y_pos += 18
        lines.append('  nsDialogs::Show')
        lines.append('FunctionEnd')
        lines.append('')
        lines.append('Function ShortcutOptions_Leave')
        for sc in _optional_shortcuts:
            lines.append(f'  ${{NSD_GetState}} $_SC_CTRL_{sc.idx} $CREATE_SC_{sc.idx}')
        lines.append('FunctionEnd')
        lines.append('')
        lines.append('Page custom ShortcutOptions_Create ShortcutOptions_Leave')
        lines.append('')

    lines.extend([
        "!insertmacro MUI_PAGE_INSTFILES",
        "Page custom Finish_Create Finish_Leave",
        "",
        "!insertmacro MUI_UNPAGE_CONFIRM",
        "!insertmacro MUI_UNPAGE_INSTFILES",
        "",
    ])

    # Localized strings for shortcut options page — emit after MUI_LANGUAGE so
    # ${LANG_*} constants are defined by MUI2.nsh and the language macros.
    # Only emit if languages are configured (otherwise suppress LangString usage).
    if _optional_shortcuts:
        if langs:  # Only if languages are configured
            lines.append('; Shortcut options localized strings')
            for sc in _optional_shortcuts:
                for lang_cfg in langs:
                    mapping = _resolve_nsis_mapping(lang_cfg)
                    lc = f'${{{mapping.lang_constant}}}'
                    label_escaped = _default_label(sc, lang_cfg)
                    label_escaped = _escape_nsis_langstring(label_escaped)
                    lines.append(f'LangString SC_LABEL_{sc.idx} {lc} "{label_escaped}"')
            lines.append('')
        else:
            lines.append('; Shortcut options localized strings')
            lines.append('')

    # Localized strings for language selection intro page (only shown when multiple languages configured)
    if langs and len(langs) > 1:
        lines.append('; Language page localized strings')
        for lang_cfg in langs:
            mapping = _resolve_nsis_mapping(lang_cfg)
            lc = f'${{{mapping.lang_constant}}}'
            title = get_translated_string(lang_cfg.name, 'langpage_title', lang_cfg.strings)
            desc = get_translated_string(lang_cfg.name, 'langpage_desc', lang_cfg.strings)
            title = ctx.resolve(title)
            title = _escape_nsis_langstring(title)
            desc = ctx.resolve(desc)
            desc = _escape_nsis_langstring(desc)
            lines.append(f'LangString LANGPAGE_TITLE {lc} "{title}"')
            lines.append(f'LangString LANGPAGE_DESC {lc} "{desc}"')
        lines.append('')

    # Localized strings for file association descriptions (if configured)
    fa_list = cfg.install.file_associations or []
    if langs and fa_list:
        fa_has_i18n = any(LangText.from_value(fa.description).translations for fa in fa_list)
        if fa_has_i18n:
            lines.append('; File association localized strings')
            for idx, fa in enumerate(fa_list):
                desc_text = LangText.from_value(fa.description)
                if not desc_text.translations:
                    continue
                for lang_cfg in langs:
                    mapping = _resolve_nsis_mapping(lang_cfg)
                    lc = f'${{{mapping.lang_constant}}}'
                    text = desc_text.get_for_language(
                        lang_cfg.name,
                        f"file_associations[{idx}].description",
                    )
                    text = ctx.resolve(text)
                    text = _escape_nsis_langstring(text)
                    lines.append(f'LangString FA_DESC_{idx} {lc} "{text}"')
            lines.append('')

    desc_text = LangText.from_value(cfg.app.description)
    # Localized strings for app description (if configured)
    if langs and desc_text.translations:
        lines.append('; App description localized strings')
        for lang_cfg in langs:
            mapping = _resolve_nsis_mapping(lang_cfg)
            lc = f'${{{mapping.lang_constant}}}'
            text = desc_text.get_for_language(lang_cfg.name, "app.description")
            text = ctx.resolve(text)
            text = _escape_nsis_langstring(text)
            lines.append(f'LangString APP_DESCRIPTION {lc} "{text}"')
        lines.append('')

    # License page LangStrings are no longer needed here — LicenseLangString
    # (emitted above with the license page) embeds the content at compile time,
    # and MUI_LICENSEPAGE_CHECKBOX provides the acceptance UI automatically.

    # Localized strings for finish-page run checkbox (if configured)
    if launch and langs:
        lines.append('; Finish page localized strings')
        for lang_cfg in langs:
            mapping = _resolve_nsis_mapping(lang_cfg)
            lc = f'${{{mapping.lang_constant}}}'
            if not label_override.is_empty():
                text = label_override.get_for_language(
                    lang_cfg.name,
                    "install.launch_on_finish_label",
                )
            else:
                text = get_translated_string(lang_cfg.name, 'finish_run', lang_cfg.strings)
            text = ctx.resolve(text)
            text = _escape_nsis_langstring(text)
            lines.append(f'LangString FINISHPAGE_RUN_TEXT {lc} "{text}"')
        lines.append('')

    # Localized strings for various prompts used by .onInit / existing-install logic
    if langs:
        lines.append('; System / existing-install localized strings')
        for lang_cfg in langs:
            mapping = _resolve_nsis_mapping(lang_cfg)
            lc = f'${{{mapping.lang_constant}}}'
            # Installer running
            text = get_translated_string(lang_cfg.name, 'installer_running', lang_cfg.strings)
            text = ctx.resolve(text)
            text = _escape_nsis_langstring(text)
            lines.append(f'LangString INSTALLER_RUNNING {lc} "{text}"')
            # Signature failed
            text = get_translated_string(lang_cfg.name, 'signature_failed', lang_cfg.strings)
            text = ctx.resolve(text)
            text = _escape_nsis_langstring(text)
            lines.append(f'LangString SIGNATURE_FAILED {lc} "{text}"')
            # Requires Windows: substitute {mv} if present
            mv = ctx.config.install.system_requirements.min_windows_version if ctx.config.install.system_requirements else ""
            text = get_translated_string(lang_cfg.name, 'requires_windows', lang_cfg.strings)
            try:
                text = text.format(mv=mv)
            except Exception:
                pass
            text = ctx.resolve(text)
            text = _escape_nsis_langstring(text)
            lines.append(f'LangString REQUIRES_WINDOWS {lc} "{text}"')
            # Disk & memory
            mb_space = (ctx.config.install.system_requirements.min_free_space_mb
                        if ctx.config.install.system_requirements else 0)
            text = get_translated_string(lang_cfg.name, 'not_enough_space', lang_cfg.strings)
            try:
                text = text.format(mb=mb_space)
            except Exception:
                pass
            text = ctx.resolve(text)
            text = _escape_nsis_langstring(text)
            lines.append(f'LangString NOT_ENOUGH_SPACE {lc} "{text}"')
            mb_mem = (ctx.config.install.system_requirements.min_ram_mb
                      if ctx.config.install.system_requirements else 0)
            text = get_translated_string(lang_cfg.name, 'not_enough_memory', lang_cfg.strings)
            try:
                text = text.format(mb=mb_mem)
            except Exception:
                pass
            text = ctx.resolve(text)
            text = _escape_nsis_langstring(text)
            lines.append(f'LangString NOT_ENOUGH_MEMORY {lc} "{text}"')
            # Need admin
            text = get_translated_string(lang_cfg.name, 'need_admin', lang_cfg.strings)
            text = ctx.resolve(text)
            text = _escape_nsis_langstring(text)
            lines.append(f'LangString NEED_ADMIN {lc} "{text}"')
            # Existing install prompts (use $R1/$R2 placeholders)
            text = get_translated_string(lang_cfg.name, 'existing_install_prompt', lang_cfg.strings)
            text = ctx.resolve(text)
            text = _escape_nsis_langstring(text)
            lines.append(f'LangString EXISTING_INSTALL_PROMPT {lc} "{text}"')
            text = get_translated_string(lang_cfg.name, 'existing_install_prompt_no_ver', lang_cfg.strings)
            text = ctx.resolve(text)
            text = _escape_nsis_langstring(text)
            lines.append(f'LangString EXISTING_INSTALL_PROMPT_NO_VER {lc} "{text}"')
            text = get_translated_string(lang_cfg.name, 'existing_install_abort', lang_cfg.strings)
            text = ctx.resolve(text)
            text = _escape_nsis_langstring(text)
            lines.append(f'LangString EXISTING_INSTALL_ABORT {lc} "{text}"')
            text = get_translated_string(lang_cfg.name, 'existing_install_abort_no_ver', lang_cfg.strings)
            text = ctx.resolve(text)
            text = _escape_nsis_langstring(text)
            lines.append(f'LangString EXISTING_INSTALL_ABORT_NO_VER {lc} "{text}"')
            # Uninstall not finished prompt
            text = get_translated_string(lang_cfg.name, 'uninstall_not_finished', lang_cfg.strings)
            text = ctx.resolve(text)
            text = _escape_nsis_langstring(text)
            lines.append(f'LangString UNINSTALL_NOT_FINISHED {lc} "{text}"')
        lines.append('')
    return lines
