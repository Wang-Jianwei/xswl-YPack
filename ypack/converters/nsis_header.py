"""
NSIS script header generation — defines, includes, unicode, icons.
"""

from __future__ import annotations

import os
from typing import List, Optional

from .context import BuildContext
from .nsis_languages import NsisLanguageMapping, get_nsis_mapping_or_fallback
from ..config import LanguageConfig
from ..languages import (
    get_translated_string,
)


def generate_header(ctx: BuildContext) -> List[str]:
    """Top-of-file defines, Unicode flag, MUI icon defines."""
    cfg = ctx.config
    lines: List[str] = [
        "; NSIS Script generated by xswl-YPack",
        "; Do not edit manually — regenerate from YAML configuration",
        "",
        "; --- Encoding ---",
        "Unicode true",
        "",
        "; --- Application Information ---",
        f'!define APP_NAME "{cfg.app.name}"',
        f'!define APP_VERSION "{cfg.app.version}"',
        f'!define APP_PUBLISHER "{cfg.app.publisher}"',
        f'!define APP_DESCRIPTION "{cfg.app.description}"',
    ]

    # REG_KEY: user-configurable application registry key.
    # Default: Software\{publisher}\{app_name}  (industry standard).
    reg_key = cfg.install.registry_key
    if not reg_key:
        reg_key = f"Software\\{cfg.app.publisher}\\{cfg.app.name}"
    reg_key = ctx.resolve(reg_key)
    lines.append(f'!define REG_KEY "{reg_key}"')
    lines.append("")

    # MUI icon defines (must appear before !include MUI2.nsh)
    install_icon = cfg.app.install_icon
    uninstall_icon = cfg.app.uninstall_icon or install_icon
    if install_icon or uninstall_icon:
        lines.append("; --- Modern UI Icons ---")
        if install_icon:
            abs_path = ctx.resolve_path(install_icon)
            rel_path = ctx.relative_to_output(abs_path) if os.path.exists(abs_path) else install_icon
            if not os.path.exists(abs_path):
                lines.append(f"; WARNING: Install icon not found: {install_icon}")
            lines.append(f'!define MUI_ICON "{rel_path}"')
        if uninstall_icon:
            abs_path = ctx.resolve_path(uninstall_icon)
            rel_path = ctx.relative_to_output(abs_path) if os.path.exists(abs_path) else uninstall_icon
            if not os.path.exists(abs_path):
                lines.append(f"; WARNING: Uninstall icon not found: {uninstall_icon}")
            lines.append(f'!define MUI_UNICON "{rel_path}"')
        lines.append("")

    # License file (put near top with other top-level defines)
    if cfg.app.license:
        abs_path = ctx.resolve_path(cfg.app.license)
        if os.path.exists(abs_path):
            rel_path = ctx.relative_to_output(abs_path)
            lines.append(f'!define LICENSE_FILE "{rel_path}"')
        else:
            lines.append(f"; WARNING: License file not found: {cfg.app.license}")
            lines.append(f'!define LICENSE_FILE "{cfg.app.license}"')

    return lines


def generate_custom_includes(ctx: BuildContext) -> List[str]:
    """Emit ``!include`` directives from ``custom_includes.nsis``."""
    includes = []
    ci = ctx.config.custom_includes
    if isinstance(ci, dict):
        includes = list(ci.get("nsis", []))
    if not includes:
        return []
    lines = ["; --- Custom NSIS Includes ---"]
    for inc in includes:
        lines.append(f'!include "{inc}"')
    lines.append("")
    return lines


def generate_general_settings(ctx: BuildContext) -> List[str]:
    """Name, OutFile, InstallDir, RequestExecutionLevel, license."""
    cfg = ctx.config
    reg_view = ctx.effective_reg_view
    lines: List[str] = [
        "; --- General Settings ---",
        f'Name "${{APP_NAME}}"',
        f'OutFile "${{APP_NAME}}-${{APP_VERSION}}-Setup.exe"',
        f'InstallDir "{ctx.resolve(cfg.install.install_dir)}"',
        f'InstallDirRegKey HKLM "${{REG_KEY}}" "InstallPath"',
        'RequestExecutionLevel admin',
    ]

    # License data belongs to general settings (keeps settings grouped together)
    if cfg.app.license:
        lines.append('LicenseData "${LICENSE_FILE}"')

    # Silent install support
    if cfg.install.silent_install:
        lines.append("SilentInstall silent")

    # Logging
    if cfg.logging and cfg.logging.enabled:
        log_path = cfg.logging.path or "$APPDATA\\${APP_NAME}\\install.log"
        resolved_path = ctx.resolve(cfg.logging.path) if cfg.logging.path else log_path
        lines.append(f'; Logging: {resolved_path} (level={cfg.logging.level})')
        lines.append(f'!define LOG_FILE "{resolved_path}"')

    # Utility includes (provide helper macros used elsewhere, e.g. ${GetSize})
    lines.append('!include "FileFunc.nsh"')

    lines.append("")
    return lines


def _resolve_nsis_mapping(lang_cfg: LanguageConfig) -> NsisLanguageMapping:
    """Resolve a LanguageConfig to NSIS-specific identifiers, with fallback."""
    return get_nsis_mapping_or_fallback(lang_cfg.name)


def generate_modern_ui(ctx: BuildContext) -> List[str]:
    """MUI2 include, page macros, language macros, finish-page run."""
    cfg = ctx.config
    # Finish page run — implement with a custom finish page checkbox instead
    # of relying on MUI_FINISHPAGE_RUN (avoids makensis 6010 warnings in some
    # MUI/NSIS versions which treat unreferenced GUIInit as an error).
    launch = cfg.install.launch_on_finish
    lines: List[str] = [
        "; --- Modern UI ---",
    ]
    lines.extend([
        '!include "MUI2.nsh"',
        "",
    ])

    # Emit fallback LANG_* constants for every configured language so
    # that LangString definitions can be placed before MUI_LANGUAGE
    # macros without causing undefined-constant errors.  The MUI_LANGUAGE
    # macro will define them again (harmlessly) when it is processed.
    langs: List[LanguageConfig] = cfg.languages or []
    if langs:
        lines.append('; --- Language constant fallbacks ---')
        for lang_cfg in langs:
            mapping = _resolve_nsis_mapping(lang_cfg)
            if mapping.lcid > 0:
                lines.extend([
                    f'!ifndef {mapping.lang_constant}',
                    f'  !define {mapping.lang_constant} {mapping.lcid}',
                    f'!endif',
                ])
        lines.append('')
    else:
        # Always define LANG_ENGLISH as safety net for description
        # LangString when no languages are configured.
        lines.extend([
            '!ifndef LANG_ENGLISH',
            '  !define LANG_ENGLISH 1033',
            '!endif',
            '',
        ])
    # If a launch-on-finish path is configured, add a localized finish-page
    # checkbox implemented with nsDialogs (more robust across MUI versions).
    if launch:
        path = ctx.resolve(launch)
        label_override = ""
        if cfg.install.launch_on_finish_label:
            label_override = ctx.resolve(cfg.install.launch_on_finish_label)
            label_override = label_override.replace('"', '$\\"')

        # When languages are configured we use a LangString reference
        # (runtime-resolved) for the checkbox label; otherwise hardcode English.
        if langs:
            finish_label = '$(FINISHPAGE_RUN_TEXT)'
        elif label_override:
            finish_label = f'"{label_override}"'
        else:
            finish_label = '"Run ${APP_NAME}"'
        lines.extend([
            'Var RUN_ON_FINISH',
            'Var _FINISH_RUN_CTRL',
            '',
            # Show/leave callbacks for the Finish page
            'Function Finish_Create',
            '  nsDialogs::Create 1018',
            '  Pop $0',
            '  StrCmp $0 error 0 +2',
            '    Abort',
            f'  ${{NSD_CreateCheckBox}} 10u 10u 100% 12u {finish_label}',
            '  Pop $_FINISH_RUN_CTRL',
            '  ${NSD_SetState} $_FINISH_RUN_CTRL 1',
            '  nsDialogs::Show',
            'FunctionEnd',
            '',
            'Function Finish_Leave',
            '  ${NSD_GetState} $_FINISH_RUN_CTRL $0',
            '  StrCmp $0 1 0 +2',
            '    StrCpy $RUN_ON_FINISH 1',
            '    Goto +2',
            '  StrCpy $RUN_ON_FINISH 0',
            '  ; If selected, run the configured program',
            f'  StrCmp $RUN_ON_FINISH "1" 0 +2',
            f'    ExecShell open "{path}"',
            'FunctionEnd',
            '',
        ])

    # UI Pages
    lines.append("; UI Pages")

    # Languages configured in YAML — determine behavior (default: no languages).
    langs = cfg.languages or []

    # Language selection behavior:
    # - No configured languages: emit MUI_LANGUAGE "English" as default
    #   (MUI2 requires at least one MUI_LANGUAGE to define its internal LangStrings).
    # - One language: emit a single MUI_LANGUAGE for that language.
    # - Multiple languages: emit a short introduction page (localized) followed
    #   by MUI_PAGE_LANGUAGE so the user can choose at install time.
    if langs:
        # Emit custom introduction page when user can choose language
        if len(langs) > 1:
            lines.extend([
                '; Language selection intro page',
                '!include "nsDialogs.nsh"',
                'Function LangSelect_Create',
                '  nsDialogs::Create 1018',
                '  Pop $0',
                '  StrCmp $0 error 0 +2',
                '    Abort',
                '  ${NSD_CreateText} 10u 4u 100% 8u $(LANGPAGE_DESC)',
                '  Pop $R9',
                '  nsDialogs::Show',
                'FunctionEnd',
                'Function LangSelect_Leave',
                '  ; no-op leave callback',
                'FunctionEnd',
                'Page custom LangSelect_Create LangSelect_Leave',
                '; Language selection via custom page above, MUI_PAGE_LANGUAGE not used',
            ])
        # Emit mapped MUI_LANGUAGE entries
        for lang_cfg in langs:
            mapping = _resolve_nsis_mapping(lang_cfg)
            lines.append(f'!insertmacro MUI_LANGUAGE "{mapping.mui_name}"')
    else:
        # No languages configured — default to English so MUI2 internal
        # LangStrings (e.g. MUI_INNERTEXT_LICENSE_BOTTOM) are defined.
        lines.append('!insertmacro MUI_LANGUAGE "English"')

    if cfg.app.license:
        lines.append('!insertmacro MUI_PAGE_LICENSE "${LICENSE_FILE}"')
    else:
        lines.append("; No license page")

    if cfg.packages:
        lines.append("!insertmacro MUI_PAGE_COMPONENTS")

    # If existing-install handling allows multiple installations, we
    # defer path-specific checks until the user has chosen an install
    # directory. Use a custom leave-callback on the directory page.
    ei = cfg.install.existing_install
    if ei and ei.allow_multiple:
        lines.extend([
            '!define MUI_PAGE_CUSTOMFUNCTION_LEAVE ExistingInstall_DirLeave',
            '!insertmacro MUI_PAGE_DIRECTORY',
            '!ifdef MUI_PAGE_CUSTOMFUNCTION_LEAVE',
            '  !undef MUI_PAGE_CUSTOMFUNCTION_LEAVE',
            '!endif',
        ])
    else:
        lines.append("!insertmacro MUI_PAGE_DIRECTORY")

    # Shortcut options page (if desktop or start-menu shortcuts are configured)
    if cfg.install.desktop_shortcut or cfg.install.start_menu_shortcut:
        lines.append('; Shortcut options page')
        lines.append('!include "nsDialogs.nsh"')
        lines.append('!include "WinMessages.nsh"')
        lines.append('Var CREATE_DESKTOP_SHORTCUT')
        lines.append('Var CREATE_START_MENU_SHORTCUT')
        lines.append('Var _SHORTCUTS_DESKTOP_CTRL')
        lines.append('Var _SHORTCUTS_START_CTRL')
        lines.append('')

        # Create function: use localized strings when languages configured,
        # otherwise fall back to literal English text (system language case).
        if langs:
            desktop_ref = '$(SHORTCUTS_DESKTOP)'
            start_ref = '$(SHORTCUTS_STARTMENU)'
        else:
            desktop_ref = '"Create desktop shortcut"'
            start_ref = '"Create start menu shortcut"'

        lines.extend([
            'Function ShortcutOptions_Create',
            '  nsDialogs::Create 1018',
            '  Pop $0',
            '  StrCmp $0 error 0 +2',
            '    Abort',
            f'  ${'{'}NSD_CreateCheckBox{'}'} 10u 10u 100% 12u {desktop_ref}',
            '  Pop $_SHORTCUTS_DESKTOP_CTRL',
            '  ${NSD_SetState} $_SHORTCUTS_DESKTOP_CTRL 1',
            f'  ${'{'}NSD_CreateCheckBox{'}'} 10u 28u 100% 12u {start_ref}',
            '  Pop $_SHORTCUTS_START_CTRL',
            '  ${NSD_SetState} $_SHORTCUTS_START_CTRL 1',
            '  nsDialogs::Show',
            'FunctionEnd',
            '',
            'Function ShortcutOptions_Leave',
            '  ${NSD_GetState} $_SHORTCUTS_DESKTOP_CTRL $0',
            '  StrCmp $0 1 0 +2',
            '    StrCpy $CREATE_DESKTOP_SHORTCUT 1',
            '  StrCpy $CREATE_DESKTOP_SHORTCUT 0',
            '  ${NSD_GetState} $_SHORTCUTS_START_CTRL $0',
            '  StrCmp $0 1 0 +2',
            '    StrCpy $CREATE_START_MENU_SHORTCUT 1',
            '  StrCpy $CREATE_START_MENU_SHORTCUT 0',
            'FunctionEnd',
            '',
            'Page custom ShortcutOptions_Create ShortcutOptions_Leave',
            '',
        ])

    lines.extend([
        "!insertmacro MUI_PAGE_INSTFILES",
        "Page custom Finish_Create Finish_Leave",
        "",
        "!insertmacro MUI_UNPAGE_CONFIRM",
        "!insertmacro MUI_UNPAGE_INSTFILES",
        "",
    ])

    # Localized strings for shortcut options page — emit after MUI_LANGUAGE so
    # ${LANG_*} constants are defined by MUI2.nsh and the language macros.
    # Only emit if languages are configured (otherwise suppress LangString usage).
    if cfg.install.desktop_shortcut or cfg.install.start_menu_shortcut:
        if langs:  # Only if languages are configured
            lines.append('; Shortcut options localized strings')
            for lang_cfg in langs:
                mapping = _resolve_nsis_mapping(lang_cfg)
                lc = f'${{{mapping.lang_constant}}}'
                desk = get_translated_string(lang_cfg.name, 'shortcuts_desktop', lang_cfg.strings)
                smenu = get_translated_string(lang_cfg.name, 'shortcuts_startmenu', lang_cfg.strings)
                lines.append(f'LangString SHORTCUTS_DESKTOP {lc} "{desk}"')
                lines.append(f'LangString SHORTCUTS_STARTMENU {lc} "{smenu}"')
            lines.append('')

    # Localized strings for language selection intro page (only shown when multiple languages configured)
    if langs and len(langs) > 1:
        lines.append('; Language page localized strings')
        for lang_cfg in langs:
            mapping = _resolve_nsis_mapping(lang_cfg)
            lc = f'${{{mapping.lang_constant}}}'
            title = get_translated_string(lang_cfg.name, 'langpage_title', lang_cfg.strings)
            desc = get_translated_string(lang_cfg.name, 'langpage_desc', lang_cfg.strings)
            lines.append(f'LangString LANGPAGE_TITLE {lc} "{title}"')
            lines.append(f'LangString LANGPAGE_DESC {lc} "{desc}"')
        lines.append('')

    # Localized strings for finish-page run checkbox (if configured)
    if launch and langs:
        lines.append('; Finish page localized strings')
        for lang_cfg in langs:
            mapping = _resolve_nsis_mapping(lang_cfg)
            lc = f'${{{mapping.lang_constant}}}'
            if cfg.install.launch_on_finish_label:
                text = label_override
            else:
                text = get_translated_string(lang_cfg.name, 'finish_run', lang_cfg.strings)
            lines.append(f'LangString FINISHPAGE_RUN_TEXT {lc} "{text}"')
        lines.append('')

    return lines
